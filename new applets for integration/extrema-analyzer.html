<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extrema Analyzer - 3D Critical Points</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #16213e 100%);
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #3a4a6b;
        }
        
        h1 {
            color: #4ecca3;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #00d9ff;
            font-size: 1.2em;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #3a4a6b;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            color: #00d9ff;
            font-size: 1.1em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .function-option {
            background: #0a0e27;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 6px;
            border: 2px solid #3a4a6b;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .function-option:hover {
            border-color: #4ecca3;
            background: #12192e;
        }
        
        .function-option.selected {
            border-color: #4ecca3;
            background: #1a2a45;
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.3);
        }
        
        .function-option .func-name {
            color: #f9d423;
            font-weight: bold;
            font-size: 1.05em;
            margin-bottom: 4px;
        }
        
        .function-option .func-expr {
            color: #aaa;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .range-input {
            display: grid;
            grid-template-columns: 30px 1fr 1fr;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .range-input label {
            color: #00d9ff;
            font-weight: bold;
        }
        
        .range-input input {
            background: #0a0e27;
            border: 1px solid #3a4a6b;
            color: #e0e0e0;
            padding: 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .analyze-btn {
            width: 100%;
            padding: 12px;
            background: #4ecca3;
            color: #0a0e27;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .analyze-btn:hover {
            background: #45b393;
            transform: translateY(-2px);
        }
        
        .analyze-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .viz-container {
            background: #16213e;
            border-radius: 10px;
            border: 2px solid #3a4a6b;
            overflow: hidden;
            position: relative;
        }
        
        #three-canvas {
            width: 100%;
            height: 700px;
            display: block;
        }
        
        .viz-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(10, 14, 39, 0.9);
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #3a4a6b;
        }
        
        .viz-controls button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: #3a4a6b;
            color: #e0e0e0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .viz-controls button:hover {
            background: #4a5a7b;
        }
        
        .status-bar {
            background: #0a0e27;
            padding: 8px 15px;
            border-top: 1px solid #3a4a6b;
            font-size: 0.9em;
            color: #f9d423;
        }
        
        .results-panel {
            background: #16213e;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #3a4a6b;
            margin-top: 20px;
        }
        
        .results-panel h2 {
            color: #4ecca3;
            margin-bottom: 15px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
        }
        
        .result-card {
            background: #0a0e27;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid;
        }
        
        .result-card.max { border-left-color: #e94560; }
        .result-card.min { border-left-color: #4ecca3; }
        .result-card.saddle { border-left-color: #00d9ff; }
        .result-card.edge { border-left-color: #f9d423; }
        
        .result-card h4 {
            margin-bottom: 8px;
            color: #00d9ff;
        }
        
        .result-card .coords {
            font-family: 'Courier New', monospace;
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 4px;
        }
        
        .legend {
            background: #0a0e27;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
        }
        
        .legend h4 {
            color: #00d9ff;
            margin-bottom: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .legend-marker {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #f9d423;
            font-size: 1.2em;
        }
        
        .error {
            background: #e94560;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        #manual-domain-inputs {
            transition: opacity 0.3s;
        }
        
        #manual-domain-inputs.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üéØ Extrema Analyzer</h1>
            <div class="subtitle">Classify critical points and find global extrema on 3D surfaces</div>
        </header>
        
        <div class="main-content">
            <div class="controls-panel">
                <div class="control-group">
                    <h3>‚úèÔ∏è Custom Function</h3>
                    <input type="text" id="custom-function" placeholder="e.g., x^2 + y^2 - 2*x*y" 
                           style="width: 100%; padding: 10px; background: #0a0e27; border: 2px solid #3a4a6b; 
                                  color: #e0e0e0; border-radius: 6px; font-family: 'Courier New', monospace;">
                    <div style="margin-top: 8px; font-size: 0.85em; color: #aaa;">
                        Use x and y as variables. Supports: +, -, *, /, ^, sin, cos, tan, sqrt, abs, exp, log
                    </div>
                    <div style="margin-top: 12px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; color: #4ecca3;">
                            <input type="checkbox" id="auto-domain" checked style="width: 18px; height: 18px; cursor: pointer;">
                            <span style="font-weight: bold;">Auto Domain (for custom functions)</span>
                        </label>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>üìä Or Select Preset</h3>
                    <div id="function-list"></div>
                </div>
                
                <div class="control-group">
                    <h3>üìê Domain</h3>
                    <div id="manual-domain-inputs">
                        <div class="range-input">
                            <label>x:</label>
                            <input type="number" id="x-min" value="-3" step="0.5">
                            <input type="number" id="x-max" value="3" step="0.5">
                        </div>
                        <div class="range-input">
                            <label>y:</label>
                            <input type="number" id="y-min" value="-3" step="0.5">
                            <input type="number" id="y-max" value="3" step="0.5">
                        </div>
                    </div>
                </div>
                
                <button class="analyze-btn" id="analyze-btn">Analyze Function</button>
                
                <div class="legend">
                    <h4>üé® Legend</h4>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #e94560;"></div>
                        <span>Local Maximum</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #4ecca3;"></div>
                        <span>Local Minimum</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #00d9ff;"></div>
                        <span>Saddle Point</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #f9d423;"></div>
                        <span>Edge Critical</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-marker" style="background: #999;"></div>
                        <span>Corner</span>
                    </div>
                </div>
            </div>
            
            <div class="viz-container">
                <div id="three-canvas"></div>
                <div class="viz-controls">
                    <button id="rotate-btn">üîÑ Auto-Rotate</button>
                    <button id="reset-view-btn">üéØ Reset View</button>
                    <button id="zoom-in-btn">üîç Zoom In</button>
                    <button id="zoom-out-btn">üîç Zoom Out</button>
                </div>
                <div class="status-bar" id="status-bar">
                    Select a function and click Analyze
                </div>
            </div>
        </div>
        
        <div class="results-panel" id="results-panel" style="display: none;">
            <h2>üìà Analysis Results</h2>
            <div id="results-content"></div>
        </div>
    </div>
    
    <script>
        // Predefined functions with curated domains
        const FUNCTIONS = [
            {
                name: "Paraboloid",
                expr: "x^2 + y^2",
                xRange: [-3, 3],
                yRange: [-3, 3],
                description: "Classic bowl shape - one minimum at origin"
            },
            {
                name: "Saddle Point",
                expr: "x^2 - y^2",
                xRange: [-3, 3],
                yRange: [-3, 3],
                description: "Hyperbolic paraboloid with saddle at origin"
            },
            {
                name: "Two Minima",
                expr: "x^4 + y^4 - 4*x^2 - 4*y^2",
                xRange: [-3, 3],
                yRange: [-3, 3],
                description: "Four local minima and one saddle at origin"
            },
            {
                name: "Three Hump Camel",
                expr: "2*x^2 - 1.05*x^4 + x^6/6 + x*y + y^2",
                xRange: [-2, 2],
                yRange: [-2, 2],
                description: "Three local minima"
            }
        ];
        
        let scene, camera, renderer, controls;
        let surface, markers = [];
        let autoRotate = false;
        let currentFunction = null; // Start with no preset selected
        let analysisResults = null;
        
        // Initialize
        function init() {
            setupFunctionList();
            setupThreeJS();
            setupEventListeners();
            animate();
        }
        
        function setupFunctionList() {
            const list = document.getElementById('function-list');
            FUNCTIONS.forEach((func, idx) => {
                const div = document.createElement('div');
                div.className = 'function-option';
                div.innerHTML = `
                    <div class="func-name">${func.name}</div>
                    <div class="func-expr">f(x,y) = ${func.expr}</div>
                `;
                div.onclick = () => selectFunction(idx);
                list.appendChild(div);
            });
        }
        
        function selectFunction(idx) {
            document.querySelectorAll('.function-option').forEach((el, i) => {
                el.classList.toggle('selected', i === idx);
            });
            currentFunction = FUNCTIONS[idx];
            
            // Clear custom function input
            document.getElementById('custom-function').value = '';
            
            // Set domain from preset (disable auto domain for presets)
            document.getElementById('auto-domain').checked = false;
            document.getElementById('manual-domain-inputs').classList.remove('disabled');
            document.getElementById('x-min').value = currentFunction.xRange[0];
            document.getElementById('x-max').value = currentFunction.xRange[1];
            document.getElementById('y-min').value = currentFunction.yRange[0];
            document.getElementById('y-max').value = currentFunction.yRange[1];
            
            updateStatus('Function selected: ' + currentFunction.name);
        }
        
        function setupThreeJS() {
            const container = document.getElementById('three-canvas');
            const width = container.clientWidth;
            const height = 700;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0e27);
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(15, 15, 15);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-10, -10, -5);
            scene.add(directionalLight2);
            
            // Grid helper
            const gridHelper = new THREE.GridHelper(20, 20, 0x3a4a6b, 0x2a3a5b);
            scene.add(gridHelper);
            
            // Axes
            const axesHelper = new THREE.AxesHelper(10);
            scene.add(axesHelper);
            
            // Mouse controls
            setupMouseControls();
        }
        
        function setupMouseControls() {
            const canvas = renderer.domElement;
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };
                    
                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 0.5),
                            toRadians(deltaMove.x * 0.5),
                            0,
                            'XYZ'
                        ));
                    
                    camera.position.applyQuaternion(deltaRotationQuaternion);
                    camera.lookAt(scene.position);
                    
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
            });
        }
        
        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }
        
        function setupEventListeners() {
            document.getElementById('analyze-btn').onclick = analyzeFunction;
            document.getElementById('rotate-btn').onclick = toggleAutoRotate;
            document.getElementById('reset-view-btn').onclick = resetView;
            document.getElementById('zoom-in-btn').onclick = () => camera.position.multiplyScalar(0.8);
            document.getElementById('zoom-out-btn').onclick = () => camera.position.multiplyScalar(1.2);
            
            // Custom function input
            document.getElementById('custom-function').oninput = (e) => {
                if (e.target.value.trim()) {
                    // Deselect all presets
                    document.querySelectorAll('.function-option').forEach(el => el.classList.remove('selected'));
                    currentFunction = null;
                    
                    // Enable auto domain for custom functions
                    document.getElementById('auto-domain').checked = true;
                    document.getElementById('manual-domain-inputs').classList.add('disabled');
                }
            };
            
            // Auto domain toggle
            document.getElementById('auto-domain').onchange = (e) => {
                const manualInputs = document.getElementById('manual-domain-inputs');
                if (e.target.checked) {
                    manualInputs.classList.add('disabled');
                } else {
                    manualInputs.classList.remove('disabled');
                }
            };
            
            // Initialize: auto domain enabled, manual inputs disabled
            document.getElementById('manual-domain-inputs').classList.add('disabled');
        }
        
        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            document.getElementById('rotate-btn').textContent = autoRotate ? '‚è∏Ô∏è Stop' : 'üîÑ Auto-Rotate';
        }
        
        function resetView() {
            camera.position.set(15, 15, 15);
            camera.lookAt(0, 0, 0);
        }
        
        function updateStatus(message) {
            document.getElementById('status-bar').textContent = message;
        }
        
        async function analyzeFunction() {
            const btn = document.getElementById('analyze-btn');
            btn.disabled = true;
            btn.textContent = 'Analyzing...';
            updateStatus('Computing critical points...');
            
            try {
                // Get function expression
                const customExpr = document.getElementById('custom-function').value.trim();
                let expr;
                
                if (customExpr) {
                    expr = customExpr;
                } else if (currentFunction) {
                    expr = currentFunction.expr;
                } else {
                    throw new Error('Please enter a function or select a preset');
                }
                
                const autoDomain = document.getElementById('auto-domain').checked;
                let xMin, xMax, yMin, yMax;
                
                if (autoDomain) {
                    // Step 1: Wide search for critical points
                    updateStatus('Searching for critical points in wide region...');
                    const wideSearch = await findCriticalPointsInWideRegion(expr);
                    
                    if (wideSearch.length === 0) {
                        // No critical points found, use default range
                        updateStatus('No critical points found, using default range...');
                        xMin = -10; xMax = 10;
                        yMin = -10; yMax = 10;
                    } else {
                        // Step 2: Calculate dynamic domain based on critical points
                        updateStatus(`Found ${wideSearch.length} critical points, calculating optimal domain...`);
                        const domain = calculateDynamicDomain(wideSearch);
                        xMin = domain.xMin;
                        xMax = domain.xMax;
                        yMin = domain.yMin;
                        yMax = domain.yMax;
                        
                        // Update display inputs (but keep them disabled)
                        document.getElementById('x-min').value = xMin.toFixed(2);
                        document.getElementById('x-max').value = xMax.toFixed(2);
                        document.getElementById('y-min').value = yMin.toFixed(2);
                        document.getElementById('y-max').value = yMax.toFixed(2);
                    }
                } else {
                    // Manual domain
                    xMin = parseFloat(document.getElementById('x-min').value);
                    xMax = parseFloat(document.getElementById('x-max').value);
                    yMin = parseFloat(document.getElementById('y-min').value);
                    yMax = parseFloat(document.getElementById('y-max').value);
                }
                
                // Step 3: Detailed analysis in the chosen domain
                updateStatus('Analyzing critical points in focused region...');
                const results = await analyzeCriticalPoints(expr, xMin, xMax, yMin, yMax);
                analysisResults = results;
                
                // Visualize
                visualizeResults(results, xMin, xMax, yMin, yMax);
                
                // Display results
                displayResults(results);
                
                updateStatus(`Analysis complete: ${results.interior.length} interior, ${results.edge.length} edge, 4 corners | Domain: [${xMin.toFixed(2)}, ${xMax.toFixed(2)}] √ó [${yMin.toFixed(2)}, ${yMax.toFixed(2)}]`);
            } catch (error) {
                console.error(error);
                updateStatus('Error: ' + error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Analyze Function';
            }
        }
        
        async function findCriticalPointsInWideRegion(expr) {
            // Search in a large region to find critical points
            const wideXMin = -20, wideXMax = 20;
            const wideYMin = -20, wideYMax = 20;
            
            // Parse and differentiate
            const f = math.parse(expr);
            const fx = math.derivative(f, 'x');
            const fy = math.derivative(f, 'y');
            const fxx = math.derivative(fx, 'x');
            const fyy = math.derivative(fy, 'y');
            const fxy = math.derivative(fx, 'y');
            
            // Compile functions
            const fFunc = f.compile();
            const fxFunc = fx.compile();
            const fyFunc = fy.compile();
            const fxxFunc = fxx.compile();
            const fyyFunc = fyy.compile();
            const fxyFunc = fxy.compile();
            
            // Find critical points with finer grid for wide search (increased from 20 to 30)
            return findCriticalPointsNumerical(fFunc, fxFunc, fyFunc, fxxFunc, fyyFunc, fxyFunc, 
                                               wideXMin, wideXMax, wideYMin, wideYMax, 30);
        }
        
        function calculateDynamicDomain(criticalPoints) {
            // Mimics MATLAB behavior: take up to first 10 critical points, add 15-20% padding
            const maxPoints = Math.min(10, criticalPoints.length);
            const points = criticalPoints.slice(0, maxPoints);
            
            if (points.length === 0) {
                return { xMin: -10, xMax: 10, yMin: -10, yMax: 10 };
            }
            
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            
            const xMinVal = Math.min(...xs);
            const xMaxVal = Math.max(...xs);
            const yMinVal = Math.min(...ys);
            const yMaxVal = Math.max(...ys);
            
            const xRange = xMaxVal - xMinVal;
            const yRange = yMaxVal - yMinVal;
            
            // Add 15% padding (or at least 1 unit)
            const xPad = Math.max(1, 0.15 * Math.max(1, xRange));
            const yPad = Math.max(1, 0.15 * Math.max(1, yRange));
            
            let xMin = xMinVal - xPad;
            let xMax = xMaxVal + xPad;
            let yMin = yMinVal - yPad;
            let yMax = yMaxVal + yPad;
            
            // If degenerate (all points at same location), widen
            if (xMax - xMin < 0.1) {
                xMin = xMinVal - 1;
                xMax = xMaxVal + 1;
            }
            if (yMax - yMin < 0.1) {
                yMin = yMinVal - 1;
                yMax = yMaxVal + 1;
            }
            
            return { xMin, xMax, yMin, yMax };
        }
        
        async function analyzeCriticalPoints(expr, xMin, xMax, yMin, yMax) {
            // Parse and differentiate
            const f = math.parse(expr);
            const fx = math.derivative(f, 'x');
            const fy = math.derivative(f, 'y');
            const fxx = math.derivative(fx, 'x');
            const fyy = math.derivative(fy, 'y');
            const fxy = math.derivative(fx, 'y');
            
            // Compile functions for evaluation
            const fFunc = f.compile();
            const fxFunc = fx.compile();
            const fyFunc = fy.compile();
            const fxxFunc = fxx.compile();
            const fyyFunc = fyy.compile();
            const fxyFunc = fxy.compile();
            
            // Find interior critical points numerically (use finer grid for focused analysis)
            const interior = findCriticalPointsNumerical(fFunc, fxFunc, fyFunc, fxxFunc, fyyFunc, fxyFunc, xMin, xMax, yMin, yMax, 25);
            
            // Analyze edges
            const edge = analyzeEdges(fFunc, expr, xMin, xMax, yMin, yMax);
            
            // Corners
            const corners = [
                { x: xMin, y: yMin, f: evalFunc(fFunc, xMin, yMin), type: 'corner' },
                { x: xMin, y: yMax, f: evalFunc(fFunc, xMin, yMax), type: 'corner' },
                { x: xMax, y: yMin, f: evalFunc(fFunc, xMax, yMin), type: 'corner' },
                { x: xMax, y: yMax, f: evalFunc(fFunc, xMax, yMax), type: 'corner' }
            ];
            
            // Find global extrema
            const allPoints = [...interior, ...edge, ...corners];
            let globalMax = allPoints[0];
            let globalMin = allPoints[0];
            
            for (const pt of allPoints) {
                if (pt.f > globalMax.f) globalMax = pt;
                if (pt.f < globalMin.f) globalMin = pt;
            }
            
            return { interior, edge, corners, globalMax, globalMin };
        }
        
        function findCriticalPointsNumerical(fFunc, fxFunc, fyFunc, fxxFunc, fyyFunc, fxyFunc, xMin, xMax, yMin, yMax, gridSize = 15) {
            const criticalPoints = [];
            
            // Grid search for approximate critical points
            const candidates = [];
            for (let i = 0; i <= gridSize; i++) {
                for (let j = 0; j <= gridSize; j++) {
                    const x = xMin + (xMax - xMin) * i / gridSize;
                    const y = yMin + (yMax - yMin) * j / gridSize;
                    
                    try {
                        const dfx = evalFunc(fxFunc, x, y);
                        const dfy = evalFunc(fyFunc, x, y);
                        const gradMag = Math.sqrt(dfx * dfx + dfy * dfy);
                        
                        // More lenient threshold for finding candidates (increased from 0.5 to 2.0)
                        if (gradMag < 2.0) { 
                            candidates.push({ x, y, gradMag });
                        }
                    } catch (e) {
                        // Skip points where derivative is undefined
                    }
                }
            }
            
            // Refine with Newton's method
            const refined = new Set();
            for (const cand of candidates) {
                let x = cand.x;
                let y = cand.y;
                
                // Newton iteration
                for (let iter = 0; iter < 30; iter++) {
                    try {
                        const dfx = evalFunc(fxFunc, x, y);
                        const dfy = evalFunc(fyFunc, x, y);
                        const hxx = evalFunc(fxxFunc, x, y);
                        const hyy = evalFunc(fyyFunc, x, y);
                        const hxy = evalFunc(fxyFunc, x, y);
                        
                        const det = hxx * hyy - hxy * hxy;
                        if (Math.abs(det) < 1e-10) break;
                        
                        const dx = (hxy * dfy - hyy * dfx) / det;
                        const dy = (hxy * dfx - hxx * dfy) / det;
                        
                        x += dx;
                        y += dy;
                        
                        if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6) break;
                    } catch (e) {
                        break;
                    }
                }
                
                // Check if converged and in domain
                if (x >= xMin && x <= xMax && y >= yMin && y <= yMax) {
                    try {
                        const dfx = evalFunc(fxFunc, x, y);
                        const dfy = evalFunc(fyFunc, x, y);
                        // More lenient convergence check (increased from 0.01 to 0.1)
                        if (Math.abs(dfx) < 0.1 && Math.abs(dfy) < 0.1) {
                            const key = `${x.toFixed(3)},${y.toFixed(3)}`; // Coarser rounding to avoid near-duplicates
                            if (!refined.has(key)) {
                                refined.add(key);
                                
                                // Classify
                                const hxx = evalFunc(fxxFunc, x, y);
                                const hyy = evalFunc(fyyFunc, x, y);
                                const hxy = evalFunc(fxyFunc, x, y);
                                const D = hxx * hyy - hxy * hxy;
                                const gradMag = Math.sqrt(dfx * dfx + dfy * dfy);
                                
                                let type;
                                if (D > 0 && hxx > 0) type = 'local min';
                                else if (D > 0 && hxx < 0) type = 'local max';
                                else if (D < 0) type = 'saddle';
                                else type = 'inconclusive';
                                
                                criticalPoints.push({
                                    x, y,
                                    f: evalFunc(fFunc, x, y),
                                    type,
                                    D, 
                                    fxx: hxx,
                                    fyy: hyy,
                                    fxy: hxy,
                                    fx: dfx,
                                    fy: dfy,
                                    gradMag
                                });
                            }
                        }
                    } catch (e) {
                        // Skip
                    }
                }
            }
            
            return criticalPoints;
        }
        
        function analyzeEdges(fFunc, expr, xMin, xMax, yMin, yMax) {
            const edgePoints = [];
            const samples = 50;
            
            // Parse for edge derivatives
            const f = math.parse(expr);
            
            // Helper to analyze 1D function along edge and compute derivatives
            function analyzeEdge1D(points, edgeName, isXFixed, fixedValue) {
                // Look for local extrema by checking neighbors
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = points[i - 1];
                    const curr = points[i];
                    const next = points[i + 1];
                    
                    if ((curr.f > prev.f && curr.f > next.f) || (curr.f < prev.f && curr.f < next.f)) {
                        // Compute approximate first and second derivatives along the edge
                        const h = Math.abs(next.t - prev.t) / 2;
                        const d1 = (next.f - prev.f) / (2 * h); // First derivative approximation
                        const d2 = (next.f - 2 * curr.f + prev.f) / (h * h); // Second derivative approximation
                        
                        edgePoints.push({
                            x: curr.x,
                            y: curr.y,
                            f: curr.f,
                            type: 'edge critical',
                            edge: edgeName,
                            d1: d1,
                            d2: d2
                        });
                    }
                }
            }
            
            // Bottom edge (y = yMin)
            const bottomEdge = [];
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const x = xMin + (xMax - xMin) * t;
                bottomEdge.push({ x, y: yMin, f: evalFunc(fFunc, x, yMin), t });
            }
            analyzeEdge1D(bottomEdge, 'y=yMin', false, yMin);
            
            // Top edge (y = yMax)
            const topEdge = [];
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const x = xMin + (xMax - xMin) * t;
                topEdge.push({ x, y: yMax, f: evalFunc(fFunc, x, yMax), t });
            }
            analyzeEdge1D(topEdge, 'y=yMax', false, yMax);
            
            // Left edge (x = xMin)
            const leftEdge = [];
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const y = yMin + (yMax - yMin) * t;
                leftEdge.push({ x: xMin, y, f: evalFunc(fFunc, xMin, y), t });
            }
            analyzeEdge1D(leftEdge, 'x=xMin', true, xMin);
            
            // Right edge (x = xMax)
            const rightEdge = [];
            for (let i = 0; i <= samples; i++) {
                const t = i / samples;
                const y = yMin + (yMax - yMin) * t;
                rightEdge.push({ x: xMax, y, f: evalFunc(fFunc, xMax, y), t });
            }
            analyzeEdge1D(rightEdge, 'x=xMax', true, xMax);
            
            return edgePoints;
        }
        
        function evalFunc(func, x, y) {
            try {
                const result = func.evaluate({ x, y });
                return isFinite(result) ? result : 0;
            } catch (e) {
                return 0;
            }
        }
        
        function visualizeResults(results, xMin, xMax, yMin, yMax) {
            // Clear existing surface and markers
            if (surface) scene.remove(surface);
            markers.forEach(m => scene.remove(m));
            markers = [];
            
            // Get current expression
            const customExpr = document.getElementById('custom-function').value.trim();
            const expr = customExpr || (currentFunction ? currentFunction.expr : null);
            if (!expr) return;
            
            // Create surface
            const resolution = 80;
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const indices = [];
            const colors = [];
            
            const f = math.compile(expr);
            
            // Find z range for coloring
            let minZ = Infinity, maxZ = -Infinity;
            const zValues = [];
            for (let i = 0; i <= resolution; i++) {
                const row = [];
                for (let j = 0; j <= resolution; j++) {
                    const x = xMin + (xMax - xMin) * i / resolution;
                    const y = yMin + (yMax - yMin) * j / resolution;
                    const z = evalFunc(f, x, y);
                    row.push(z);
                    minZ = Math.min(minZ, z);
                    maxZ = Math.max(maxZ, z);
                }
                zValues.push(row);
            }
            
            // Build geometry
            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = xMin + (xMax - xMin) * i / resolution;
                    const y = yMin + (yMax - yMin) * j / resolution;
                    const z = zValues[i][j];
                    
                    vertices.push(x, z, y); // Note: THREE.js y is up
                    
                    // Color based on height
                    const t = (z - minZ) / (maxZ - minZ || 1);
                    const color = new THREE.Color();
                    color.setHSL(0.6 - t * 0.6, 0.8, 0.5);
                    colors.push(color.r, color.g, color.b);
                }
            }
            
            // Build indices
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const a = i * (resolution + 1) + j;
                    const b = a + 1;
                    const c = a + resolution + 1;
                    const d = c + 1;
                    
                    indices.push(a, b, c);
                    indices.push(b, d, c);
                }
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();
            
            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 30
            });
            
            surface = new THREE.Mesh(geometry, material);
            scene.add(surface);
            
            // Add markers
            const markerSize = 0.3;
            
            // Interior critical points
            for (const pt of results.interior) {
                let color;
                if (pt.type === 'local max') color = 0xe94560;
                else if (pt.type === 'local min') color = 0x4ecca3;
                else if (pt.type === 'saddle') color = 0x00d9ff;
                else color = 0x999999;
                
                const marker = createMarker(pt.x, pt.y, pt.f, color, markerSize);
                scene.add(marker);
                markers.push(marker);
            }
            
            // Edge points
            for (const pt of results.edge) {
                const marker = createMarker(pt.x, pt.y, pt.f, 0xf9d423, markerSize * 0.8);
                scene.add(marker);
                markers.push(marker);
            }
            
            // Corners
            for (const pt of results.corners) {
                const marker = createMarker(pt.x, pt.y, pt.f, 0x999999, markerSize * 0.7);
                scene.add(marker);
                markers.push(marker);
            }
        }
        
        function createMarker(x, y, z, color, size) {
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshBasicMaterial({ color });
            const marker = new THREE.Mesh(geometry, material);
            marker.position.set(x, z, y); // Note: THREE.js y is up
            
            // Add a small ring for visibility
            const ringGeo = new THREE.RingGeometry(size * 1.2, size * 1.5, 16);
            const ringMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.position.set(x, z, y);
            ring.lookAt(camera.position);
            scene.add(ring);
            markers.push(ring);
            
            return marker;
        }
        
        function displayResults(results) {
            const panel = document.getElementById('results-panel');
            const content = document.getElementById('results-content');
            panel.style.display = 'block';
            
            let html = '<div class="results-grid">';
            
            // Global max
            html += `
                <div class="result-card max">
                    <h4>üî∫ Global Maximum</h4>
                    <div class="coords">x = ${results.globalMax.x.toFixed(4)}</div>
                    <div class="coords">y = ${results.globalMax.y.toFixed(4)}</div>
                    <div class="coords">f = ${results.globalMax.f.toFixed(4)}</div>
                    <div style="color: #aaa; margin-top: 5px; font-size: 0.85em;">${results.globalMax.type}</div>
                </div>
            `;
            
            // Global min
            html += `
                <div class="result-card min">
                    <h4>üîª Global Minimum</h4>
                    <div class="coords">x = ${results.globalMin.x.toFixed(4)}</div>
                    <div class="coords">y = ${results.globalMin.y.toFixed(4)}</div>
                    <div class="coords">f = ${results.globalMin.f.toFixed(4)}</div>
                    <div style="color: #aaa; margin-top: 5px; font-size: 0.85em;">${results.globalMin.type}</div>
                </div>
            `;
            
            html += '</div>';
            
            // Detailed analysis for interior critical points
            if (results.interior.length > 0) {
                html += '<h3 style="color: #00d9ff; margin-top: 25px; margin-bottom: 15px;">Interior Critical Points (‚àáf = 0)</h3>';
                html += '<div style="display: grid; gap: 15px;">';
                
                for (const pt of results.interior) {
                    const cardClass = pt.type === 'local max' ? 'max' : pt.type === 'local min' ? 'min' : 'saddle';
                    html += `
                        <div class="result-card ${cardClass}" style="padding: 20px;">
                            <h4 style="margin-bottom: 12px;">${pt.type.charAt(0).toUpperCase() + pt.type.slice(1)}</h4>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <div style="color: #f9d423; font-weight: bold; margin-bottom: 5px;">Location:</div>
                                    <div class="coords">x = ${pt.x.toFixed(6)}</div>
                                    <div class="coords">y = ${pt.y.toFixed(6)}</div>
                                    <div class="coords">f(x,y) = ${pt.f.toFixed(6)}</div>
                                </div>
                                
                                <div>
                                    <div style="color: #f9d423; font-weight: bold; margin-bottom: 5px;">First Derivative:</div>
                                    <div class="coords">‚àÇf/‚àÇx = ${pt.fx ? pt.fx.toFixed(6) : '0.000000'}</div>
                                    <div class="coords">‚àÇf/‚àÇy = ${pt.fy ? pt.fy.toFixed(6) : '0.000000'}</div>
                                    <div class="coords">||‚àáf|| = ${pt.gradMag ? pt.gradMag.toFixed(6) : '0.000000'}</div>
                                </div>
                            </div>
                            
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #3a4a6b;">
                                <div style="color: #f9d423; font-weight: bold; margin-bottom: 5px;">Hessian Matrix:</div>
                                <div style="font-family: 'Courier New', monospace; font-size: 0.9em; color: #aaa;">
                                    H = [${pt.fxx ? pt.fxx.toFixed(4) : '0'}   ${pt.fxy ? pt.fxy.toFixed(4) : '0'}]<br>
                                    &nbsp;&nbsp;&nbsp;&nbsp;[${pt.fxy ? pt.fxy.toFixed(4) : '0'}   ${pt.fyy ? pt.fyy.toFixed(4) : '0'}]
                                </div>
                            </div>
                            
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #3a4a6b;">
                                <div style="color: #f9d423; font-weight: bold; margin-bottom: 5px;">Second Derivative Test:</div>
                                <div class="coords">D = det(H) = ${pt.D.toFixed(6)}</div>
                                <div class="coords">f_xx = ${pt.fxx ? pt.fxx.toFixed(6) : '0'}</div>
                                <div style="color: #4ecca3; margin-top: 8px; font-size: 0.9em;">
                                    ${pt.D > 0 && pt.fxx > 0 ? '‚úì D > 0 and f_xx > 0 ‚Üí Local minimum' :
                                      pt.D > 0 && pt.fxx < 0 ? '‚úì D > 0 and f_xx < 0 ‚Üí Local maximum' :
                                      pt.D < 0 ? '‚úì D < 0 ‚Üí Saddle point' :
                                      '‚ö† D = 0 ‚Üí Test inconclusive'}
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
            }
            
            // Boundary edge critical points
            if (results.edge.length > 0) {
                html += '<h3 style="color: #f9d423; margin-top: 25px; margin-bottom: 15px;">Edge Critical Points</h3>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px;">';
                
                for (const pt of results.edge) {
                    html += `
                        <div class="result-card edge" style="padding: 15px;">
                            <h4 style="margin-bottom: 8px;">${pt.type}</h4>
                            <div class="coords">x = ${pt.x.toFixed(6)}</div>
                            <div class="coords">y = ${pt.y.toFixed(6)}</div>
                            <div class="coords">f = ${pt.f.toFixed(6)}</div>
                            <div style="color: #aaa; margin-top: 8px; font-size: 0.85em;">
                                Edge: ${pt.edge}
                            </div>
                            ${pt.d1 !== undefined ? `
                                <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #3a4a6b;">
                                    <div style="color: #f9d423; font-size: 0.85em;">1D Analysis:</div>
                                    <div class="coords" style="font-size: 0.85em;">g'(t) ‚âà ${pt.d1.toFixed(6)}</div>
                                    <div class="coords" style="font-size: 0.85em;">g''(t) = ${pt.d2.toFixed(6)}</div>
                                    <div style="color: #4ecca3; margin-top: 5px; font-size: 0.8em;">
                                        ${pt.d2 > 0 ? '‚úì g\'\'(t) > 0 ‚Üí Local min' :
                                          pt.d2 < 0 ? '‚úì g\'\'(t) < 0 ‚Üí Local max' :
                                          '‚ö† g\'\'(t) = 0 ‚Üí Inconclusive'}
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
                
                html += '</div>';
            }
            
            content.innerHTML = html;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (autoRotate) {
                const radius = Math.sqrt(
                    camera.position.x * camera.position.x + 
                    camera.position.z * camera.position.z
                );
                const angle = Math.atan2(camera.position.z, camera.position.x);
                camera.position.x = radius * Math.cos(angle + 0.005);
                camera.position.z = radius * Math.sin(angle + 0.005);
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // Start
        init();
    </script>
</body>
</html>
